[{"categories":["linux"],"content":"Human: 一个golang的hello world Assistant: 在Go语言中（通常被称为Golang），一个简单的Hello World程序如下所示： package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } Human: 详细解释一下操作系统对他的编译，以及操作系统是如何将可执行程序运行，并最终在屏幕上打印出相关字符的 Assistant: 当你在操作系统上编译并运行一个Golang程序时，会经历以下几个阶段： 编译阶段：Golang编译器会将源代码（如上述的Hello World程序）转换为可执行的机器代码。这个过程包括词法分析、语法分析、中间代码生成、机器代码生成等多个步骤。 链接阶段：链接器将编译得到的目标文件与系统库和其他依赖库进行链接，生成最终的可执行文件。这个过程主要负责解决各个代码模块之间的相互引用问题。 加载阶段：操作系统会将可执行文件加载到内存中，并为其分配内存空间。这包括分配代码段、数据段、堆和栈等内存区域。 执行阶段：操作系统创建一个新的进程并将程序的控制权交给该进程。程序开始执行main函数，并按照程序中的指令顺序执行。 在Hello World程序中，fmt.Println(\"Hello, World!\")负责将文本输出到屏幕。具体来说，这个函数会执行以下操作： 调用底层的系统调用（如Linux上的write()），将字符串\"Hello, World!“写入到标准输出（stdout）的文件描述符（通常是1）。 在这个过程中，操作系统会将输出数据传递给控制台或终端模拟器。这些工具会解析数据流并将相应的字符显示在屏幕上。 当所有字符都被输出后，fmt.Println()函数会添加一个换行符，使得控制台光标移动到下一行。 最后，程序运行结束，操作系统会回收该进程所占用的资源，并将控制权归还给操作系统。 Human: 执行阶段的具体细节 Assistant: 在执行阶段，操作系统会完成以下步骤来运行一个程序： 创建进程：操作系统首先创建一个新的进程来运行可执行程序。这涉及为进程分配内存、设置进程控制块（Process Control Block，PCB）以存储进程状态、优先级、资源使用情况等信息。 加载程序：操作系统将可执行程序加载到进程的内存空间。这通常包括将代码段、数据段、堆和栈等内存区域分配给进程，并将可执行程序的内容加载到相应的内存区域。 初始化进程环境：操作系统为进程设置环境变量、文件描述符、信号处理器等。这些信息有助于程序与操作系统及其他程序进行交互。 设置程序计数器（Program Counter, PC）：操作系统将程序计数器设置为程序入口点，即main函数的起始地址。程序计数器用于指示下一条要执行的指令。 开始执行：操作系统将控制权交给新创建的进程。这时，程序开始按照程序计数器指示的指令顺序执行。对于Golang程序，main函数是程序的入口点。 系统调用：当程序需要与操作系统交互时（例如分配内存、访问文件或执行fmt.Println()函数将文本输出到屏幕），程序会发起系统调用。系统调用会使程序暂时挂起，操作系统接管控制权，执行相应的内核操作，然后将结果返回给程序并恢复程序的执行。 执行结束：当程序的main函数执行完毕，程序会发出一个终止信号，通知操作系统进程已经结束。操作系统会回收进程占用的内存和资源，关闭所有打开的文件描述符，最后将控制权归还给操作系统。 需要注意的是，这里提供的执行阶段的具体细节是一个简化的概述。在实际操作系统中，进程调度、内存管理等方面可能会有更复杂的实现。 Human: linux是如何创建进程的 Assistant: 在Linux操作系统中，创建进程的过程通常涉及两个关键的系统调用：fork()和exec()。以下是Linux创建进程的详细步骤： 调用fork()函数：fork()函数会创建一个新进程，这个新进程（子进程）是当前进程（父进程）的一个副本。子进程继承了父进程的内存空间、环境变量、打开的文件描述符等资源。fork()函数在父进程和子进程中都返回一个值。在子进程中，返回值为0，而在父进程中，返回值为子进程的进程ID（PID）。 判断返回值：程序通过检查fork()函数的返回值来确定当前进程是父进程还是子进程。在子进程中继续执行，而父进程则可以选择等待子进程的结束或继续执行其他任务。 子进程调用exec()函数：在子进程中，exec()函数用于替换当前进程的内存映像，加载新的程序。exec()函数有多个变体，如execl()、execv()、execle()、execve()等，它们提供了不同的参数传递方式。exec()函数接收要执行的程序的路径以及传递给新程序的参数列表。当exec()函数调用成功时，原进程的内存映像被新程序所替换，新程序从其入口点开始执行。 新程序执行：新程序开始按照程序计数器指示的指令顺序执行。新程序会继承原子进程的资源，如文件描述符等，但代码段和数据段已被替换为新程序的内容。 进程结束：当新程序执行完成，进程会通过exit()系统调用通知操作系统。操作系统会回收进程占用的资源，关闭打开的文件描述符，并将控制权归还给操作系统。 需要注意的是，在现代Linux系统中，fork()函数在某些情况下可能会被clone()函数替代，以提供更细粒度的控制。例如，clone()函数可以用于创建新的线程、命名空间等。 Human: 当我运行一个新的程序时，这个程序的父进程是谁 Assistant: 当你在Linux系统上运行一个新的程序时，该程序的父进程通常是你在其中启动新程序的shell。例如，如果你在Bash shell中运行一个程序，Bash进程就是这个新程序的父进程。 当你在shell中输入命令并按下回车键，shell会解析该命令并创建一个子进程来运行相应的程序。如前所述，这个过程包括调用fork()和exec()系统调用。在这种情况下，新程序的父进程就是原先运行的shell进程。 Human: 加载阶段的详细细节 Assistant: 在加载阶段，操作系统会将可执行程序加载到新创建进程的内存空间。以下是加载阶段的详细步骤： 读取可执行文件格式：操作系统首先读取可执行文件的格式，以确定如何加载和运行程序。在Linux系统上，可执行文件通常采用ELF（Executable and Linkable Format）格式。ELF文件包含程序的元数据（例如程序的入口点地址、代码段、数据段等）以及程序的实际代码和数据。 分配内存空间：操作系统会为新进程分配内存空间。这包括为程序的代码段、数据段、堆和栈等内存区域分配空间。代码段通常是只读的，存储程序的机器代码；数据段包含全局变量和静态变量；堆用于存储程序运行时动态分配的内存；栈用于存储函数调用的局部变量、参数和返回地址等。 加载程序到内存：操作系统将可执行文件的内容加载到相应的内存区域。例如，代码段被加载到代码区，数据段被加载到数据区。操作系统还需要处理文件中的重定位信息，以确保程序中的符号引用正确地映射到实际的内存地址。 处理动态链接：如果程序依赖于动态链接库（如Linux中的共享库），操作系统会将这些库加载到进程的地址空间，并解析符号引用。在Linux系统上，动态链接器（如ld-linux.so）负责完成这个过程。动态链接器会根据程序的依赖信息加载共享库，并更新程序中的符号引用以指向库中的正确地址。 初始化进程控制块（PCB）：操作系统会为新进程创建一个进程控制块（PCB），用于存储进程的状态、优先级、资源使用情况等信息。此外，操作系统还会设置程序计数器（Program Counter, PC），以指向程序的入口点地址。 设置运行环境：操作系统设置进程的运行环境，包括环境变量、文件描述符、信号处理器等。这些信息有助于程序与操作系统及其他程序进行交互。 加载阶段完成后，操作系统将控制权交给新进程，程序开始按照程序计数器指示的指令顺序执行。请注意，这里提供的加载阶段的详细细节是一个简化的概述。在实际操作系统中，内存管理、动态链接等方面可能会有更复杂的实现。 ","date":"2023-03-29","objectID":"/program-running/:0:0","tags":["linux"],"title":"[linux]linux程序运行过程","uri":"/program-running/"},{"categories":["Algorithm"],"content":"后缀数组概念 设有一字符串s 子串 字符串s的子串为s中从下标i到下标j的连续的一段字符组成的字符串s[i...j]，假设字符串下标从1开始. 后缀 指从某个位置i开始到整个字符串末尾的一个子串，记作suffix(i) = s[i...len(s)]. 字符串大小比较 按字典顺序比较，显然两个不同开头位置的后缀suffix(i)和suffix(j)不可能相等，即suffix(i) != suffix(j) (i != j) 后缀数组 sa为一个一维数组，保存了1~n的某个排列sa[1]、sa[2]、... sa[n]，满足suffix(sa[i]) \u003c suffix(sa[i + 1]) 名次数组 rank为一个名次数组，其中rank[i]为suffix(i)在所有后缀中从小到大的名次为多少。 总的来说就是，后缀数组sa记录了排第几的是哪个后缀，名次数组rank记录了当前这个后缀排第几。 例子： 设字符串s = aabaaaab suffix(1) = aabaaaab suffix(2) = abaaaab suffix(3) = baaaab suffix(4) = aaaab suffix(5) = aaab suffix(6) = aab suffix(7) = ab suffix(8) = b 最小的后缀应该是suffix(4)，然后是suffix(5) ... 得到以下后缀数组 sa[1] = 4 // aaaab sa[2] = 5 // aaab sa[3] = 6 // aab sa[4] = 1 // aabaaaab sa[5] = 7 // ab sa[6] = 2 // abaaaab sa[7] = 8 // b sa[8] = 3 // baaaab 由此也能得到名次数组 rank|4|6|8|1|2|3|5|7| --------------------- s |a|a|b|a|a|a|a|b| 设字符串长度为n。为了方便比较大小，可以在字符串后面添加一个字符，这个字符没有在前面的字符出现过，而且比前面的字符都要小。在求出名次数组后，可以仅用O(1)的时间比较任意两个后缀的大小。在求出后缀数组或者名次数组其中的一个，可以在O(n)的时间求出另外一个。 ","date":"2023-03-13","objectID":"/suffix_array/:1:0","tags":["C++","Algorithm"],"title":"[算法刷题]后缀数组Suffix Array","uri":"/suffix_array/"},{"categories":["Algorithm"],"content":"构造后缀数组 ","date":"2023-03-13","objectID":"/suffix_array/:2:0","tags":["C++","Algorithm"],"title":"[算法刷题]后缀数组Suffix Array","uri":"/suffix_array/"},{"categories":["Algorithm"],"content":"倍增算法 O(NlogN) // 后缀数组，生成sa，rk，height数组 template\u003cclass T=string,int range=128\u003e struct SuffixArray{ T s; int n,bucketRange; int sa[range],second[range],bucket[range],mem[range],rk_mem[range+1],rk2_mem[range+1],height[range],*rk,*rk2; SuffixArray(const T\u0026_s):s(_s),n(s.size()),bucketRange(range){ rk=rk_mem; rk2=rk2_mem; rk[n]=rk2[n]=-1; memset(bucket,0,sizeof(bucket)); for(int i=0;i\u003cn;i++)bucket[rk[i]=s[i]]++; for(int i=1;i\u003cbucketRange;i++)bucket[i]+=bucket[i-1]; for(int i=0;i\u003cn;i++)sa[--bucket[rk[i]]]=i; for(int w=1;;w\u003c\u003c=1){ int j=0; for(int i=n-w;i\u003cn;i++)second[j++]=i; for(int i=0;i\u003cn;i++)if(sa[i]\u003e=w)second[j++]=sa[i]-w; memset(bucket,0,sizeof(bucket)); for(int i=0;i\u003cn;i++)bucket[mem[i]=rk[second[i]]]++; for(int i=1;i\u003cbucketRange;i++)bucket[i]+=bucket[i-1]; for(int i=n-1;i\u003e=0;i--)sa[--bucket[mem[i]]]=second[i]; bucketRange=0; for(int i=0;i\u003cn;i++){ rk2[sa[i]]=!i||(rk[sa[i]]==rk[sa[i-1]]\u0026\u0026rk[sa[i]+w]==rk[sa[i-1]+w])?bucketRange:++bucketRange; } swap(rk,rk2); if(++bucketRange==n)break; } } void getHeight(){ memset(height,0xff,sizeof(height)); for(int i=0,h=0;i\u003cn;i++){ if(h)h--; if(rk[i])while(sa[rk[i]-1]+h\u003cn\u0026\u0026s[i+h]==s[sa[rk[i]-1]+h])h++; height[rk[i]]=h; } } }; ","date":"2023-03-13","objectID":"/suffix_array/:2:1","tags":["C++","Algorithm"],"title":"[算法刷题]后缀数组Suffix Array","uri":"/suffix_array/"},{"categories":["Algorithm"],"content":"3DC算法 O(N) // TODO ","date":"2023-03-13","objectID":"/suffix_array/:2:2","tags":["C++","Algorithm"],"title":"[算法刷题]后缀数组Suffix Array","uri":"/suffix_array/"},{"categories":["Algorithm"],"content":"SA-IS O(N) 模板 class SuffixArray { public: using size_type = unsigned; using pointer = size_type*; using const_pointer = const size_type*; private: template\u003ctypename It\u003e inline static void get_sbuk(It s, pointer sbuk, size_type n, size_type m) { std::fill_n(sbuk, m, 0); for (size_type i = 0;i \u003c n;++i) ++sbuk[s[i]]; std::partial_sum(sbuk, sbuk + m, sbuk); } inline static void lbuk_to_sbuk(const_pointer lbuk, pointer sbuk, size_type n, size_type m) { std::copy_n(lbuk + 1, m - 1, sbuk); sbuk[m - 1] = n; } inline static void sbuk_to_lbuk(pointer lbuk, const_pointer sbuk, size_type n, size_type m) { std::copy_n(sbuk, m - 1, lbuk + 1); lbuk[0] = 0; } template\u003cbool Stage, typename It\u003e inline static void induced_sort(It s, pointer sa, pointer lbuk, pointer sbuk, size_type n, size_type m) { constexpr size_type mask = size_type(1) \u003c\u003c (CHAR_BIT * sizeof(size_type) - 1); using value_type = typename std::iterator_traits\u003cIt\u003e::value_type; value_type prev = s[n - 1], cur; pointer ptr = sa + lbuk[prev]; *ptr++ = n - 1; for (size_type p, i = 0;i \u003c n;++i) { if ((p = sa[i] - 1) \u0026 mask) continue; if ((cur = s[p]) \u003c s[p + 1]) { sa[i] = ~p; continue; } if (cur != prev) { lbuk[prev] = ptr - sa; ptr = sa + lbuk[prev = cur]; } *ptr++ = p; if (!Stage) sa[i] = 0; } ptr = sa + sbuk[prev = 0]; sbuk_to_lbuk(lbuk, sbuk, n, m); for (size_type p, i = n;i-- \u003e 0;) { if ((p = ~sa[i]) \u0026 mask) continue; if ((cur = s[p]) \u003e s[p + 1]) { sa[i] = p + 1; continue; } if (cur != prev) { sbuk[prev] = ptr - sa; ptr = sa + sbuk[prev = cur]; } *--ptr = ~p + 1; sa[i] = Stage ? p + 1 : 0; } } template\u003ctypename It\u003e inline static size_type fill_lms_char(It s, pointer sa, pointer mid, pointer sbuk, size_type n) { using value_type = typename std::iterator_traits\u003cIt\u003e::value_type; const pointer len = mid; pointer pos = mid; value_type prev, cur = s[n - 1]; for (size_type j = n - 1, i = n - 1;i \u003e 0;) { do prev = cur; while (i \u003e 0 \u0026\u0026 (cur = s[--i]) \u003e= prev); if (cur \u003e= prev) break; do prev = cur; while (i \u003e 0 \u0026\u0026 (cur = s[--i]) \u003c= prev); if (cur \u003c= prev) break; const size_type p = i + 1; sa[--sbuk[s[p]]] = p; len[p / 2] = j - i; *--pos = j = p; } return mid - pos; } template\u003ctypename It\u003e inline static void fill_lms_suffix(It s, pointer sa, const_pointer pos, pointer sbuk, size_type n, size_type m, size_type n0) { using value_type = typename std::iterator_traits\u003cIt\u003e::value_type; value_type prev = m, cur; size_type j = n; for (size_type p, i = n0;i \u003e 0;) { if ((cur = s[p = pos[sa[--i]]]) != prev) { const size_type b = sbuk[prev = cur]; while (j \u003e b) sa[--j] = 0; } sa[--j] = p; } while (j \u003e 0) sa[--j] = 0; } template\u003ctypename It\u003e inline static size_type rename(It s, pointer sa, const_pointer len, size_type n, size_type m, size_type n0) { for (size_type p, j = 0, i = 0;j \u003c n0;++i) { if ((p = sa[i]) != 0) { sa[i] = 0; sa[j++] = p; } } const pointer sa0 = sa, s0 = sa + n0; size_type m0 = 0, plen = 0; It ppos = s; for (size_type i = 0;i \u003c n0;++i) { const size_type p = sa[i], nlen = len[p / 2]; if (nlen != plen || !std::equal(ppos, ppos + plen, s + p)) ++m0; s0[p / 2] = m0; ppos = s + p; plen = nlen; } for (size_type p, j = 0, i = 0;j \u003c n0;++i) if ((p = s0[i]) != 0) s0[j++] = p - 1; return m0; } public: template\u003ctypename It\u003e static void suffix_sort(It s, pointer sa, pointer buf, pointer lbuk, pointer sbuk, size_type n, size_type m) { static_assert(std::is_same_v\u003ctypename std::iterator_traits\u003cIt\u003e::iterator_category, std::random_access_iterator_tag\u003e); std::fill_n(sa, n, 0); get_sbuk(s, sbuk, n, m); sbuk_to_lbuk(lbuk, sbuk, n, m); const pointer mid = buf + n / 2; const size_type n0 = fill_lms_char(s, sa, mid, sbuk, n); const pointer len = mid, pos = mid - n0; lbuk_to_sbuk(lbuk, sbuk, n, m); induced_sort\u003c0\u003e(s, sa, lbuk, sbuk, n, m); const size_type m0 = rename(s, sa, len, n, m, n0); const pointer sa0 = sa, s0 = sa + n0; if (m0 \u003c n0) suffix_sort(s0, sa0, mid, sbuk, sbuk + m0, n0, m0); else for (size_type i = 0;i \u003c n0;++i) sa0[s0[i]] = i; lbuk_to_sbuk(lbuk, sbuk, n, m); fill_lms_suffix(s, sa, pos, sbuk","date":"2023-03-13","objectID":"/suffix_array/:2:3","tags":["C++","Algorithm"],"title":"[算法刷题]后缀数组Suffix Array","uri":"/suffix_array/"},{"categories":["Algorithm"],"content":"后缀数组相关题目 LeetCode 1923.最长公共子路径 主代码（后缀数组为倍增算法模板） class Solution { //用counter来计数覆盖的path数量 //为何不用bool数组或者 bitset: 初始化的时间复杂度会超标 struct{ int mark[100000]={0},num=0; int timestamp=0; void reset(){ timestamp++; num=0; } void add(int i){ if(mark[i]!=timestamp){ mark[i]=timestamp; num++; } } }counter; public: int longestCommonSubpath(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 paths) { int m=paths.size(); //all存放全部路径，sublen表示每个位置作为开头的最长子串长度，belong表示所属的路 vector\u003cint\u003eall,sublen,belong; for(int i=0;i\u003cm;i++){ for(int j=0;j\u003cpaths[i].size();j++){ all.push_back(paths[i][j]); sublen.push_back(paths[i].size()-j); belong.push_back(i); } } //后缀数组结构体自动生成 sa,rk,height 数组 SuffixArray\u003cvector\u003cint\u003e,100000\u003eSA(all); SA.getHeight(); auto sa=SA.sa,h=SA.height; //二分找出最低的height，使某个高于height的区间内包含所有的path int low=0,high=all.size(); while(low\u003chigh){ int mid=(low+high+1)/2; bool flag=false; for(int i=0,j;i\u003call.size();i=j){ counter.reset(); for(j=i;j\u003call.size()\u0026\u0026(j==i||h[j]\u003e=mid);j++){ if(sublen[sa[j]]\u003e=mid)counter.add(belong[sa[j]]); } if(counter.num==m){ flag=true; break; } } if(flag)low=mid; else high=mid-1; } return low; } }; SA-IS模板主代码 const int N = 200010; class Solution { public: int s[N]; // 将串拼接起来,中间用不同字符隔开,结尾改为0 int belong[N]; // 当前字符属于第几个朋友 int longestCommonSubpath(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 paths) { int len = 0; int m = paths.size(); // 朋友数量 for (int i = 0; i \u003c m; i ++ ) { for (int c: paths[i]) { s[len] = c + 1; // 从1开始 belong[len] = i + 1; len ++ ; } s[len ++ ] = 1e5 + 10; } s[ -- len] = 0; SuffixArray sa(s, len + 1, 1e6); // 找到大于等于答案的每一段height区间[i, j] // 如果[i - 1, j]的后缀包含了所有朋友则满足条件 auto check = [\u0026](int mid) -\u003e bool { for (int i = 1; i \u003c= len; i ++ ) { if (sa.ht[i] \u003e= mid) { vector\u003cbool\u003e seen(m + 1, false); int j = i + 1; while (j \u003c= len \u0026\u0026 sa.ht[j] \u003e= mid) j ++ ; j -- ; int c = 0; for (int k = i - 1; k \u003c= j; k ++ ) { if (seen[belong[sa.sa[k]]]) continue; c ++ ; seen[belong[sa.sa[k]]] = true; } if (c == m) return true; i = j + 1; } } return false; }; // 二分答案 int l = 0, r = len; while (l \u003c r) { int mid = (l + r) \u003e\u003e 1; if (!check(mid + 1)) r = mid; else l = mid + 1; } return l; } }; ","date":"2023-03-13","objectID":"/suffix_array/:3:0","tags":["C++","Algorithm"],"title":"[算法刷题]后缀数组Suffix Array","uri":"/suffix_array/"},{"categories":["Golang"],"content":"业务场景 对一些业务进行检查，比如权限检查，审核检查等。 ","date":"2023-02-20","objectID":"/golang_permit_check/:1:0","tags":["Golang"],"title":"[Golang]优雅实现「业务/权限」检查","uri":"/golang_permit_check/"},{"categories":["Golang"],"content":"实现思路 对应权限用“枚举”定义，由于Golang没有枚举，所以用常量和后面的map代替。常量定义如下 const ( PermitZero = 0 PermitOne = 1 PermitTwo = 2 PermitThree = 3 ... ) 定义Check方法，每个Check方法参数一致，返回一致。 type CheckParams struct { p1 string p2 int64 p3 Context ... } func CheckZero(p *CheckParams) error {} func CheckOne(p *CheckParams) error {} func CheckTwo(p *CheckParams) error {} func CheckThree(p *CheckParams) error {} ... 把权限顺序放入列表里，对权限与函数进行map对应 var ( CheckFunc = map[int]func(*CheckParams) error { PermitZero: CheckZero, PermitOne: CheckOne, PermitTwo: CheckTwo, PermitThree: CheckThree, ... } CheckOrder = []int { PermitZero = 0 PermitOne = 1 PermitTwo = 2 PermitThree = 3 ... } ) 业务逻辑编写，遍历CheckOrder，通过位检查权限中是否需要检查当前项目，调用Check函数检查 func IsSet(s uint64, b int) uint64 { return s \u0026 (1 \u003c\u003c b) } for _, index := range CheckOrder { if IsSet(permit, index) != 0 { baseRet := CheckFunc[index](params) if baseRet != nil { log.Error(...) return } } } ","date":"2023-02-20","objectID":"/golang_permit_check/:2:0","tags":["Golang"],"title":"[Golang]优雅实现「业务/权限」检查","uri":"/golang_permit_check/"},{"categories":["linux"],"content":"创建proxy.sh文件 #!/bin/bash hostip=$(cat /etc/resolv.conf |grep -oP '(?\u003c=nameserver\\ ).*') https_proxy=\"http://${hostip}:7890\" http_proxy=\"http://${hostip}:7890\" function set_proxy() { export http_proxy=\"${http_proxy}\" export https_proxy=\"${https_proxy}\" echo \"env http/https proxy set.\" } function unset_proxy(){ unset http_proxy unset https_proxy echo \"env proxy unset\" } if [ \"$1\" = \"set\" ]; then set_proxy elif [ \"$1\" = \"unset\" ]; then unset_proxy else set_proxy fi 保存之后chmod +x proxy.sh ","date":"2022-11-28","objectID":"/wsl-proxy/:1:0","tags":["linux","proxy"],"title":"[linux]wsl配置使用本地clash代理","uri":"/wsl-proxy/"},{"categories":["linux"],"content":"使用说明 windows开启clash wsl运行source proxy.sh [set] 开启 wsl运行source proxy.sh unset 关闭 ","date":"2022-11-28","objectID":"/wsl-proxy/:2:0","tags":["linux","proxy"],"title":"[linux]wsl配置使用本地clash代理","uri":"/wsl-proxy/"},{"categories":["Algorithm"],"content":"简介 用于本地测试有二叉树的算法 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ void trimLeftTrailingSpaces(string \u0026input) { input.erase(input.begin(), find_if(input.begin(), input.end(), [](int ch) { return !isspace(ch); })); } void trimRightTrailingSpaces(string \u0026input) { input.erase(find_if(input.rbegin(), input.rend(), [](int ch) { return !isspace(ch); }).base(), input.end()); } TreeNode* stringToTreeNode(string input) { trimLeftTrailingSpaces(input); trimRightTrailingSpaces(input); input = input.substr(1, input.length() - 2); if (!input.size()) { return nullptr; } string item; stringstream ss; ss.str(input); getline(ss, item, ','); TreeNode* root = new TreeNode(stoi(item)); queue\u003cTreeNode*\u003e nodeQueue; nodeQueue.push(root); while (true) { TreeNode* node = nodeQueue.front(); nodeQueue.pop(); if (!getline(ss, item, ',')) { break; } trimLeftTrailingSpaces(item); if (item != \"null\") { int leftNumber = stoi(item); node-\u003eleft = new TreeNode(leftNumber); nodeQueue.push(node-\u003eleft); } if (!getline(ss, item, ',')) { break; } trimLeftTrailingSpaces(item); if (item != \"null\") { int rightNumber = stoi(item); node-\u003eright = new TreeNode(rightNumber); nodeQueue.push(node-\u003eright); } } return root; } string integerVectorToString(vector\u003cint\u003e list, int length = -1) { if (length == -1) { length = list.size(); } if (length == 0) { return \"[]\"; } string result; for(int index = 0; index \u003c length; index++) { int number = list[index]; result += to_string(number) + \", \"; } return \"[\" + result.substr(0, result.length() - 2) + \"]\"; } ","date":"2022-10-06","objectID":"/string2treenode/:1:0","tags":["C++","Algorithm"],"title":"[算法刷题]C++输入String生成二叉树","uri":"/string2treenode/"},{"categories":["C++"],"content":"简介 定义在头文件\u003cqueue\u003e中 priority_queue\u003cType, Container, Functional\u003e template\u003c class T, class Container = std::vector\u003cT\u003e, class Compare = std::less\u003ctypename Container::value_type\u003e class priority_queue; 常用操作： top() empty() size() push() emplace() pop() ","date":"2022-06-25","objectID":"/c-stl-priority_queue/:1:0","tags":["C++","STL"],"title":"[C++]priority_queue使用技巧","uri":"/c-stl-priority_queue/"},{"categories":["C++"],"content":"大、小根堆 对于单一数值类型如int类型： #include \u003cfunctional\u003e // 因为用到了greater\u003cint\u003e和less\u003cint\u003e#include \u003cqueue\u003e // 小顶堆 priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q; // 大顶堆 priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e q; // 默认大顶堆 priority_queue\u003cint\u003e q; 对于自定义类型，需要指明容器，以及优先级规则，如pair\u003cint, int\u003e类别 typedef pair\u003cint, int\u003e PII; priority_queue\u003cPII, vector\u003cPII\u003e, decltype(\u0026cmp)\u003e q(cmp); // cmp为一个比较函数 Example code: #include \u003ciostream\u003e#include \u003cqueue\u003e using namespace std; typedef pair\u003cint, int\u003e PII; // 假设按照pair的第二个数来进行排序，这样说明是按第二个数升序，是小根堆，没啥好说的，记住就行了。 bool cmp(const PII\u0026 p1, const PII\u0026 p2) { return p1.second \u003e p2.second; } int main() { vector\u003cPII\u003e pairs = {{1, 4}, {2, 9}, {5, 3}, {4, 1}, {3, 6}}; priority_queue\u003cPII, vector\u003cPII\u003e, decltype(\u0026cmp)\u003e q(cmp); // 声明了一个pair的根据第二个数比较的小根堆 for (auto p : pairs) { q.push(p); } while (q.size()) { cout \u003c\u003c q.top().first \u003c\u003c q.top().second \u003c\u003c endl; } return 0; } output: 4 1 5 3 1 4 3 6 2 9 ","date":"2022-06-25","objectID":"/c-stl-priority_queue/:2:0","tags":["C++","STL"],"title":"[C++]priority_queue使用技巧","uri":"/c-stl-priority_queue/"},{"categories":["C++"],"content":"综合案例 #include \u003cfunctional\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003ciostream\u003e template\u003ctypename T\u003e void print_queue(T q) { // NB: pass by value so the print uses a copy while(!q.empty()) { std::cout \u003c\u003c q.top() \u003c\u003c ' '; q.pop(); } std::cout \u003c\u003c '\\n'; } int main() { const auto data = {1,8,5,6,3,4,0,9,7,2}; // 默认的是大根堆 // 输出结果: 9 8 7 6 5 4 3 2 1 0 std::priority_queue\u003cint\u003e q; for(int n : data) q.push(n); print_queue(q); // 声明了一个小根堆 // 输出结果：0 1 2 3 4 5 6 7 8 9 std::priority_queue\u003cint, std::vector\u003cint\u003e, std::greater\u003cint\u003e\u003e q2(data.begin(), data.end()); print_queue(q2); // 利用lambda表达式来写比较函数 // 按给定规则，小于号说明是个大根堆，根据两个数与1异或之后的大小。 auto cmp = [](int left, int right) { return (left ^ 1) \u003c (right ^ 1); }; std::priority_queue\u003cint, std::vector\u003cint\u003e, decltype(cmp)\u003e q3(cmp); for(int n : data) q3.push(n); print_queue(q3); } output: 9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 8 9 6 7 4 5 2 3 0 1 ","date":"2022-06-25","objectID":"/c-stl-priority_queue/:3:0","tags":["C++","STL"],"title":"[C++]priority_queue使用技巧","uri":"/c-stl-priority_queue/"},{"categories":["C++"],"content":"总结 默认是大根堆，大的数在顶上 greater\u003cint\u003e是小根堆，less\u003cint\u003e是大根堆。 // greater: constexpr bool operator()(const T \u0026lhs, const T \u0026rhs) const { return lhs \u003e rhs; // assumes that the implementation uses a flat address space } // less: constexpr bool operator()(const T \u0026lhs, const T \u0026rhs) const { return lhs \u003c rhs; // assumes that the implementation uses a flat address space } 自定义比较函数 // 小根堆 bool cmp(const T\u0026 t1, const T\u0026 t2) { t1 \u003e t2; } // 大根堆 bool cmp(const T\u0026 t1, const T\u0026 t2) { t1 \u003c t2; } 自定义比较函数写法priority_queue\u003cT, vector\u003cT\u003e, decltype(\u0026cmp)\u003e q(cmp); ","date":"2022-06-25","objectID":"/c-stl-priority_queue/:4:0","tags":["C++","STL"],"title":"[C++]priority_queue使用技巧","uri":"/c-stl-priority_queue/"},{"categories":["C++"],"content":" 定义在头文件 \u003citerator\u003e ","date":"2022-06-20","objectID":"/advanceprevnext/:0:0","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"std::advance 增加给定的迭代器 it 以 n 个元素的步长。 若 n 为负，则迭代器自减。该情况下， InputIt 必须满足遗留双向迭代器 (LegacyBidirectionalIterator) 的要求，否则行为未定义。 ","date":"2022-06-20","objectID":"/advanceprevnext/:1:0","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"参数 it : 要前进的迭代器 n : it 要前进的元素数 ","date":"2022-06-20","objectID":"/advanceprevnext/:1:1","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"返回值 (无) ","date":"2022-06-20","objectID":"/advanceprevnext/:1:2","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"复杂度 线性。 然而，若 InputIt 额外满足遗留随机访问迭代器 (LegacyRandomAccessIterator) 的要求，则复杂度是常数。 ","date":"2022-06-20","objectID":"/advanceprevnext/:1:3","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"示例 Code: #include \u003ciostream\u003e#include \u003citerator\u003e#include \u003cvector\u003e int main() { std::vector\u003cint\u003e v{ 3, 1, 4 }; auto vi = v.begin(); std::advance(vi, 2); std::cout \u003c\u003c *vi \u003c\u003c ' '; vi = v.end(); std::advance(vi, -2); std::cout \u003c\u003c *vi \u003c\u003c '\\n'; } Output: 4 1 ","date":"2022-06-20","objectID":"/advanceprevnext/:1:4","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"std::prev ","date":"2022-06-20","objectID":"/advanceprevnext/:2:0","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"参数 it : 迭代器 n : it 要被减少的次数 ","date":"2022-06-20","objectID":"/advanceprevnext/:2:1","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"返回值 返回迭代器 it 的第 n 个前驱。 ","date":"2022-06-20","objectID":"/advanceprevnext/:2:2","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"复杂度 线性。 然而，若 BidirIt 还满足遗留随机访问迭代器 (LegacyRandomAccessIterator) 的要求，则复杂度为常数。 ","date":"2022-06-20","objectID":"/advanceprevnext/:2:3","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"示例 Code: #include \u003ciostream\u003e#include \u003citerator\u003e#include \u003cvector\u003e int main() { std::vector\u003cint\u003e v{ 3, 1, 4 }; auto it = v.end(); auto pv = std::prev(it, 2); std::cout \u003c\u003c *pv \u003c\u003c '\\n'; it = v.begin(); pv = std::prev(it, -2); std::cout \u003c\u003c *pv \u003c\u003c '\\n'; } Output: 1 4 ","date":"2022-06-20","objectID":"/advanceprevnext/:2:4","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"std::next ","date":"2022-06-20","objectID":"/advanceprevnext/:3:0","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"参数 it : 迭代器 n : 要前进的元素数 ","date":"2022-06-20","objectID":"/advanceprevnext/:3:1","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"返回值 迭代器 it 的第 n 个后继。 ","date":"2022-06-20","objectID":"/advanceprevnext/:3:2","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"复杂度 线性。 然而，若 InputIt 还满足遗留随机访问迭代器 (LegacyRandomAccessIterator) 的要求，则复杂度为常数。 ","date":"2022-06-20","objectID":"/advanceprevnext/:3:3","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["C++"],"content":"示例 Code: #include \u003ciostream\u003e#include \u003citerator\u003e#include \u003cvector\u003e int main() { std::vector\u003cint\u003e v{ 4, 5, 6 }; auto it = v.begin(); auto nx = std::next(it, 2); std::cout \u003c\u003c *it \u003c\u003c ' ' \u003c\u003c *nx \u003c\u003c '\\n'; it = v.end(); nx = std::next(it, -2); std::cout \u003c\u003c ' ' \u003c\u003c *nx \u003c\u003c '\\n'; } Output: 4 6 5 ","date":"2022-06-20","objectID":"/advanceprevnext/:3:4","tags":["C++","STL"],"title":"[C++]advance(), prev() and next()","uri":"/advanceprevnext/"},{"categories":["Spring"],"content":"全局代理 在C:\\Users\\用户\\.gradle文件夹下打开或新建gradle.properties 增加内容： # gradle 代理配置 systemProp.socks.proxyHost=xxx systemProp.socks.proxyPort=xxx systemProp.socks.proxyUser=xxx systemProp.socks.proxyPassword=xxx systemProp.http.proxyHost=xxx systemProp.http.proxyPort=xxx systemProp.http.proxyUser=xxx systemProp.http.proxyPassword=xxx systemProp.https.proxyHost=xxx systemProp.https.proxyPort=xxx systemProp.https.proxyUser=xxx systemProp.https.proxyPassword=xxx ","date":"2022-06-17","objectID":"/gradle-proxy/:1:0","tags":["Spring Boot"],"title":"[Java]Gradle设置代理","uri":"/gradle-proxy/"},{"categories":["Spring"],"content":"项目代理 在项目build.gradle同级目录下新建gradle.properties 增加内容： 分别配置socks、http、https的代理IP、代理端口、用户名和密码： # gradle 代理配置 systemProp.socks.proxyHost=xxx systemProp.socks.proxyPort=xxx systemProp.socks.proxyUser=xxx systemProp.socks.proxyPassword=xxx systemProp.http.proxyHost=xxx systemProp.http.proxyPort=xxx systemProp.http.proxyUser=xxx systemProp.http.proxyPassword=xxx systemProp.https.proxyHost=xxx systemProp.https.proxyPort=xxx systemProp.https.proxyUser=xxx systemProp.https.proxyPassword=xxx 例如我用的clash代理，默认socks和http端口均是7890，没有密码,我的配置文件为： systemProp.socks.proxyHost=127.0.0.1 systemProp.socks.proxyPort=7890 systemProp.http.proxyHost=127.0.0.1 systemProp.http.proxyPort=7890 systemProp.https.proxyHost=127.0.0.1 systemProp.https.proxyPort=7890 ","date":"2022-06-17","objectID":"/gradle-proxy/:2:0","tags":["Spring Boot"],"title":"[Java]Gradle设置代理","uri":"/gradle-proxy/"},{"categories":null,"content":"$$ e^{ i \\pi}+1=0 $$ ","date":"2022-05-31","objectID":"/first/:0:0","tags":null,"title":"Hello world.","uri":"/first/"}]