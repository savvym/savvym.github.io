---
title: "[linux]linux程序运行过程"
date: 2023-03-29
summary: "linux是如何运行一个程序的"
categories:
- linux
tags:
- linux
# hidemeta: true
---

**Human:**
一个golang的hello world

***

**Assistant:**

在Go语言中（通常被称为Golang），一个简单的Hello World程序如下所示：

```golang
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}

```

***

**Human:**
详细解释一下操作系统对他的编译，以及操作系统是如何将可执行程序运行，并最终在屏幕上打印出相关字符的

***

**Assistant:**

当你在操作系统上编译并运行一个Golang程序时，会经历以下几个阶段：

1. <strong>编译阶段</strong>：Golang编译器会将源代码（如上述的Hello World程序）转换为可执行的机器代码。这个过程包括词法分析、语法分析、中间代码生成、机器代码生成等多个步骤。

2. <strong>链接阶段</strong>：链接器将编译得到的目标文件与系统库和其他依赖库进行链接，生成最终的可执行文件。这个过程主要负责解决各个代码模块之间的相互引用问题。

3. <strong>加载阶段</strong>：操作系统会将可执行文件加载到内存中，并为其分配内存空间。这包括分配代码段、数据段、堆和栈等内存区域。

4. <strong>执行阶段</strong>：操作系统创建一个新的进程并将程序的控制权交给该进程。程序开始执行`main`函数，并按照程序中的指令顺序执行。



在Hello World程序中，`fmt.Println("Hello, World!")`负责将文本输出到屏幕。具体来说，这个函数会执行以下操作：

1. 调用底层的系统调用（如Linux上的`write()`），将字符串"Hello, World!"写入到标准输出（stdout）的文件描述符（通常是1）。

2. 在这个过程中，操作系统会将输出数据传递给控制台或终端模拟器。这些工具会解析数据流并将相应的字符显示在屏幕上。

3. 当所有字符都被输出后，`fmt.Println()`函数会添加一个换行符，使得控制台光标移动到下一行。

4. 最后，程序运行结束，操作系统会回收该进程所占用的资源，并将控制权归还给操作系统。




***

**Human:**
执行阶段的具体细节

***

**Assistant:**

在执行阶段，操作系统会完成以下步骤来运行一个程序：

1. <strong>创建进程</strong>：操作系统首先创建一个新的进程来运行可执行程序。这涉及为进程分配内存、设置进程控制块（Process Control Block，PCB）以存储进程状态、优先级、资源使用情况等信息。

2. <strong>加载程序</strong>：操作系统将可执行程序加载到进程的内存空间。这通常包括将代码段、数据段、堆和栈等内存区域分配给进程，并将可执行程序的内容加载到相应的内存区域。

3. <strong>初始化进程环境</strong>：操作系统为进程设置环境变量、文件描述符、信号处理器等。这些信息有助于程序与操作系统及其他程序进行交互。

4. <strong>设置程序计数器（Program Counter, PC）</strong>：操作系统将程序计数器设置为程序入口点，即`main`函数的起始地址。程序计数器用于指示下一条要执行的指令。

5. <strong>开始执行</strong>：操作系统将控制权交给新创建的进程。这时，程序开始按照程序计数器指示的指令顺序执行。对于Golang程序，`main`函数是程序的入口点。

6. <strong>系统调用</strong>：当程序需要与操作系统交互时（例如分配内存、访问文件或执行`fmt.Println()`函数将文本输出到屏幕），程序会发起系统调用。系统调用会使程序暂时挂起，操作系统接管控制权，执行相应的内核操作，然后将结果返回给程序并恢复程序的执行。

7. <strong>执行结束</strong>：当程序的`main`函数执行完毕，程序会发出一个终止信号，通知操作系统进程已经结束。操作系统会回收进程占用的内存和资源，关闭所有打开的文件描述符，最后将控制权归还给操作系统。



需要注意的是，这里提供的执行阶段的具体细节是一个简化的概述。在实际操作系统中，进程调度、内存管理等方面可能会有更复杂的实现。


***

**Human:**
linux是如何创建进程的

***

**Assistant:**

在Linux操作系统中，创建进程的过程通常涉及两个关键的系统调用：`fork()`和`exec()`。以下是Linux创建进程的详细步骤：

1. <strong>调用`fork()`函数</strong>：`fork()`函数会创建一个新进程，这个新进程（子进程）是当前进程（父进程）的一个副本。子进程继承了父进程的内存空间、环境变量、打开的文件描述符等资源。`fork()`函数在父进程和子进程中都返回一个值。在子进程中，返回值为0，而在父进程中，返回值为子进程的进程ID（PID）。

2. <strong>判断返回值</strong>：程序通过检查`fork()`函数的返回值来确定当前进程是父进程还是子进程。在子进程中继续执行，而父进程则可以选择等待子进程的结束或继续执行其他任务。

3. <strong>子进程调用`exec()`函数</strong>：在子进程中，`exec()`函数用于替换当前进程的内存映像，加载新的程序。`exec()`函数有多个变体，如`execl()`、`execv()`、`execle()`、`execve()`等，它们提供了不同的参数传递方式。`exec()`函数接收要执行的程序的路径以及传递给新程序的参数列表。当`exec()`函数调用成功时，原进程的内存映像被新程序所替换，新程序从其入口点开始执行。

4. <strong>新程序执行</strong>：新程序开始按照程序计数器指示的指令顺序执行。新程序会继承原子进程的资源，如文件描述符等，但代码段和数据段已被替换为新程序的内容。

5. <strong>进程结束</strong>：当新程序执行完成，进程会通过`exit()`系统调用通知操作系统。操作系统会回收进程占用的资源，关闭打开的文件描述符，并将控制权归还给操作系统。



需要注意的是，在现代Linux系统中，`fork()`函数在某些情况下可能会被`clone()`函数替代，以提供更细粒度的控制。例如，`clone()`函数可以用于创建新的线程、命名空间等。


***

**Human:**
当我运行一个新的程序时，这个程序的父进程是谁

***

**Assistant:**

当你在Linux系统上运行一个新的程序时，该程序的父进程通常是你在其中启动新程序的shell。例如，如果你在Bash shell中运行一个程序，Bash进程就是这个新程序的父进程。

当你在shell中输入命令并按下回车键，shell会解析该命令并创建一个子进程来运行相应的程序。如前所述，这个过程包括调用`fork()`和`exec()`系统调用。在这种情况下，新程序的父进程就是原先运行的shell进程。


***

**Human:**
加载阶段的详细细节

***

**Assistant:**

在加载阶段，操作系统会将可执行程序加载到新创建进程的内存空间。以下是加载阶段的详细步骤：

1. <strong>读取可执行文件格式</strong>：操作系统首先读取可执行文件的格式，以确定如何加载和运行程序。在Linux系统上，可执行文件通常采用ELF（Executable and Linkable Format）格式。ELF文件包含程序的元数据（例如程序的入口点地址、代码段、数据段等）以及程序的实际代码和数据。

2. <strong>分配内存空间</strong>：操作系统会为新进程分配内存空间。这包括为程序的代码段、数据段、堆和栈等内存区域分配空间。代码段通常是只读的，存储程序的机器代码；数据段包含全局变量和静态变量；堆用于存储程序运行时动态分配的内存；栈用于存储函数调用的局部变量、参数和返回地址等。

3. <strong>加载程序到内存</strong>：操作系统将可执行文件的内容加载到相应的内存区域。例如，代码段被加载到代码区，数据段被加载到数据区。操作系统还需要处理文件中的重定位信息，以确保程序中的符号引用正确地映射到实际的内存地址。

4. <strong>处理动态链接</strong>：如果程序依赖于动态链接库（如Linux中的共享库），操作系统会将这些库加载到进程的地址空间，并解析符号引用。在Linux系统上，动态链接器（如`ld-linux.so`）负责完成这个过程。动态链接器会根据程序的依赖信息加载共享库，并更新程序中的符号引用以指向库中的正确地址。

5. <strong>初始化进程控制块（PCB）</strong>：操作系统会为新进程创建一个进程控制块（PCB），用于存储进程的状态、优先级、资源使用情况等信息。此外，操作系统还会设置程序计数器（Program Counter, PC），以指向程序的入口点地址。

6. <strong>设置运行环境</strong>：操作系统设置进程的运行环境，包括环境变量、文件描述符、信号处理器等。这些信息有助于程序与操作系统及其他程序进行交互。



加载阶段完成后，操作系统将控制权交给新进程，程序开始按照程序计数器指示的指令顺序执行。请注意，这里提供的加载阶段的详细细节是一个简化的概述。在实际操作系统中，内存管理、动态链接等方面可能会有更复杂的实现。